// @ts-check
const _ = require(`lodash`)

const { createPluginConfig } = require(`./plugin-options`)
const { fetchContentTypes } = require(`./fetch`)
const { CODES } = require(`./report`)

async function getContentTypesFromContentFul({
  cache,
  reporter,
  pluginConfig,
}) {
  // Get content type items from Contentful
  const contentTypeItems = await fetchContentTypes({ pluginConfig, reporter })

  // Check for restricted content type names and set id based on useNameForId
  const useNameForId = pluginConfig.get(`useNameForId`)
  const restrictedContentTypes = [`entity`, `reference`, `asset`]

  if (pluginConfig.get(`enableTags`)) {
    restrictedContentTypes.push(`tags`)
  }

  contentTypeItems.forEach(contentTypeItem => {
    // Establish identifier for content type
    //  Use `name` if specified, otherwise, use internal id (usually a natural-language constant,
    //  but sometimes a base62 uuid generated by Contentful, hence the option)
    let contentTypeItemId
    if (useNameForId) {
      contentTypeItemId = contentTypeItem.name.toLowerCase()
    } else {
      contentTypeItemId = contentTypeItem.sys.id.toLowerCase()
    }

    if (restrictedContentTypes.includes(contentTypeItemId)) {
      reporter.panic({
        id: CODES.FetchContentTypes,
        context: {
          sourceMessage: `Restricted ContentType name found. The name "${contentTypeItemId}" is not allowed.`,
        },
      })
    }
  })

  // Store processed content types in cache for sourceNodes
  const sourceId = `${pluginConfig.get(`spaceId`)}-${pluginConfig.get(
    `environment`
  )}`
  const CACHE_CONTENT_TYPES = `contentful-content-types-${sourceId}`
  await cache.set(CACHE_CONTENT_TYPES, contentTypeItems)

  return contentTypeItems
}

export async function createSchemaCustomization(
  { schema, actions, reporter, cache },
  pluginOptions
) {
  const { createTypes } = actions

  const pluginConfig = createPluginConfig(pluginOptions)

  let contentTypeItems
  if (process.env.GATSBY_WORKER_ID) {
    const sourceId = `${pluginConfig.get(`spaceId`)}-${pluginConfig.get(
      `environment`
    )}`
    contentTypeItems = await cache.get(`contentful-content-types-${sourceId}`)
  } else {
    contentTypeItems = await getContentTypesFromContentFul({
      cache,
      reporter,
      pluginConfig,
    })
  }

  const contentfulTypes = [
    schema.buildInterfaceType({
      name: `ContentfulEntry`,
      fields: {
        contentful_id: { type: `String!` },
        id: { type: `ID!` },
        node_locale: { type: `String!` },
      },
      extensions: { infer: false },
      interfaces: [`Node`],
    }),
    schema.buildInterfaceType({
      name: `ContentfulReference`,
      fields: {
        contentful_id: { type: `String!` },
        id: { type: `ID!` },
      },
      extensions: { infer: false },
    }),
    schema.buildObjectType({
      name: `ContentfulAsset`,
      fields: {
        contentful_id: { type: `String!` },
        id: { type: `ID!` },
      },
      interfaces: [`ContentfulReference`, `Node`],
    }),
  ]

  // Create types for each content type
  contentTypeItems.forEach(contentTypeItem =>
    contentfulTypes.push(
      schema.buildObjectType({
        name: _.upperFirst(
          _.camelCase(
            `Contentful ${
              pluginConfig.get(`useNameForId`)
                ? contentTypeItem.name
                : contentTypeItem.sys.id
            }`
          )
        ),
        fields: {
          contentful_id: { type: `String!` },
          id: { type: `ID!` },
          node_locale: { type: `String!` },
        },
        interfaces: [`ContentfulReference`, `ContentfulEntry`, `Node`],
      })
    )
  )

  if (pluginConfig.get(`enableTags`)) {
    contentfulTypes.push(
      schema.buildObjectType({
        name: `ContentfulTag`,
        fields: {
          name: { type: `String!` },
          contentful_id: { type: `String!` },
          id: { type: `ID!` },
        },
        interfaces: [`Node`],
        extensions: { dontInfer: {} },
      })
    )
  }

  createTypes(contentfulTypes)
}
